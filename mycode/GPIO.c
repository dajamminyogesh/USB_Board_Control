/*---------------------------------------------------------------------*/
/* --- STC MCU Limited ------------------------------------------------*/
/* --- STC 1T Series MCU Demo Programme -------------------------------*/
/* --- Mobile: (86)13922805190 ----------------------------------------*/
/* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
/* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
/* --- Web: www.STCMCU.com --------------------------------------------*/
/* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
/* --- QQ:  800003751 -------------------------------------------------*/
/* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序            */
/*---------------------------------------------------------------------*/

/***************	功能说明	****************

本文件为STC8系列的端口初始化程序,用户几乎可以不修改这个程序.

******************************************/

#include "GPIO.h"

//========================================================================
// 函数: u8	GPIO_Inilize(u8 GPIO, GPIO_InitTypeDef *GPIOx)
// 描述: 初始化IO口.
// 参数: GPIOx: 结构参数,请参考timer.h里的定义.
// 返回: 成功返回0, 空操作返回1,错误返回2.
// 版本: V1.0, 2012-10-22
//========================================================================
u8 GPIO_Inilize(u8 GPIO, GPIO_InitTypeDef *GPIOx) {
  if (GPIO > GPIO_P7) return 1;             // 空操作
  if (GPIOx->Mode > GPIO_OUT_PP) return 2;  // 错误
  if (GPIO == GPIO_P0) {
    if (GPIOx->Mode == GPIO_PullUp) P0M1 &= ~GPIOx->Pin, P0M0 &= ~GPIOx->Pin;  // 上拉准双向口
    if (GPIOx->Mode == GPIO_HighZ) P0M1 |= GPIOx->Pin, P0M0 &= ~GPIOx->Pin;    // 浮空输入
    if (GPIOx->Mode == GPIO_OUT_OD) P0M1 |= GPIOx->Pin, P0M0 |= GPIOx->Pin;    // 开漏输出
    if (GPIOx->Mode == GPIO_OUT_PP) P0M1 &= ~GPIOx->Pin, P0M0 |= GPIOx->Pin;   // 推挽输出
  }
  if (GPIO == GPIO_P1) {
    if (GPIOx->Mode == GPIO_PullUp) P1M1 &= ~GPIOx->Pin, P1M0 &= ~GPIOx->Pin;  // 上拉准双向口
    if (GPIOx->Mode == GPIO_HighZ) P1M1 |= GPIOx->Pin, P1M0 &= ~GPIOx->Pin;    // 浮空输入
    if (GPIOx->Mode == GPIO_OUT_OD) P1M1 |= GPIOx->Pin, P1M0 |= GPIOx->Pin;    // 开漏输出
    if (GPIOx->Mode == GPIO_OUT_PP) P1M1 &= ~GPIOx->Pin, P1M0 |= GPIOx->Pin;   // 推挽输出
  }
  if (GPIO == GPIO_P2) {
    if (GPIOx->Mode == GPIO_PullUp) P2M1 &= ~GPIOx->Pin, P2M0 &= ~GPIOx->Pin;  // 上拉准双向口
    if (GPIOx->Mode == GPIO_HighZ) P2M1 |= GPIOx->Pin, P2M0 &= ~GPIOx->Pin;    // 浮空输入
    if (GPIOx->Mode == GPIO_OUT_OD) P2M1 |= GPIOx->Pin, P2M0 |= GPIOx->Pin;    // 开漏输出
    if (GPIOx->Mode == GPIO_OUT_PP) P2M1 &= ~GPIOx->Pin, P2M0 |= GPIOx->Pin;   // 推挽输出
  }
  if (GPIO == GPIO_P3) {
    if (GPIOx->Mode == GPIO_PullUp) P3M1 &= ~GPIOx->Pin, P3M0 &= ~GPIOx->Pin;  // 上拉准双向口
    if (GPIOx->Mode == GPIO_HighZ) P3M1 |= GPIOx->Pin, P3M0 &= ~GPIOx->Pin;    // 浮空输入
    if (GPIOx->Mode == GPIO_OUT_OD) P3M1 |= GPIOx->Pin, P3M0 |= GPIOx->Pin;    // 开漏输出
    if (GPIOx->Mode == GPIO_OUT_PP) P3M1 &= ~GPIOx->Pin, P3M0 |= GPIOx->Pin;   // 推挽输出
  }
  if (GPIO == GPIO_P4) {
    if (GPIOx->Mode == GPIO_PullUp) P4M1 &= ~GPIOx->Pin, P4M0 &= ~GPIOx->Pin;  // 上拉准双向口
    if (GPIOx->Mode == GPIO_HighZ) P4M1 |= GPIOx->Pin, P4M0 &= ~GPIOx->Pin;    // 浮空输入
    if (GPIOx->Mode == GPIO_OUT_OD) P4M1 |= GPIOx->Pin, P4M0 |= GPIOx->Pin;    // 开漏输出
    if (GPIOx->Mode == GPIO_OUT_PP) P4M1 &= ~GPIOx->Pin, P4M0 |= GPIOx->Pin;   // 推挽输出
  }
  if (GPIO == GPIO_P5) {
    if (GPIOx->Mode == GPIO_PullUp) P5M1 &= ~GPIOx->Pin, P5M0 &= ~GPIOx->Pin;  // 上拉准双向口
    if (GPIOx->Mode == GPIO_HighZ) P5M1 |= GPIOx->Pin, P5M0 &= ~GPIOx->Pin;    // 浮空输入
    if (GPIOx->Mode == GPIO_OUT_OD) P5M1 |= GPIOx->Pin, P5M0 |= GPIOx->Pin;    // 开漏输出
    if (GPIOx->Mode == GPIO_OUT_PP) P5M1 &= ~GPIOx->Pin, P5M0 |= GPIOx->Pin;   // 推挽输出
  }
  if (GPIO == GPIO_P6) {
    if (GPIOx->Mode == GPIO_PullUp) P6M1 &= ~GPIOx->Pin, P6M0 &= ~GPIOx->Pin;  // 上拉准双向口
    if (GPIOx->Mode == GPIO_HighZ) P6M1 |= GPIOx->Pin, P6M0 &= ~GPIOx->Pin;    // 浮空输入
    if (GPIOx->Mode == GPIO_OUT_OD) P6M1 |= GPIOx->Pin, P6M0 |= GPIOx->Pin;    // 开漏输出
    if (GPIOx->Mode == GPIO_OUT_PP) P6M1 &= ~GPIOx->Pin, P6M0 |= GPIOx->Pin;   // 推挽输出
  }
  if (GPIO == GPIO_P7) {
    if (GPIOx->Mode == GPIO_PullUp) P7M1 &= ~GPIOx->Pin, P7M0 &= ~GPIOx->Pin;  // 上拉准双向口
    if (GPIOx->Mode == GPIO_HighZ) P7M1 |= GPIOx->Pin, P7M0 &= ~GPIOx->Pin;    // 浮空输入
    if (GPIOx->Mode == GPIO_OUT_OD) P7M1 |= GPIOx->Pin, P7M0 |= GPIOx->Pin;    // 开漏输出
    if (GPIOx->Mode == GPIO_OUT_PP) P7M1 &= ~GPIOx->Pin, P7M0 |= GPIOx->Pin;   // 推挽输出
  }
  return 0;  // 成功
}
void GPIO_config(void) {
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_InitStructure.Pin  = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;  // p12 p13 p14 P15 为随动输入口
  GPIO_InitStructure.Mode = GPIO_HighZ;
  GPIO_Inilize(GPIO_P1, &GPIO_InitStructure);

  GPIO_InitStructure.Pin  = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_7;  // led2 buzzer led8 为随动输出口
  GPIO_InitStructure.Mode = GPIO_OUT_PP;
  GPIO_Inilize(GPIO_P1, &GPIO_InitStructure);

  GPIO_InitStructure.Pin  = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
  GPIO_InitStructure.Mode = GPIO_OUT_PP;
  GPIO_Inilize(GPIO_P3, &GPIO_InitStructure);

  GPIO_InitStructure.Pin  = GPIO_Pin_4;
  GPIO_InitStructure.Mode = GPIO_OUT_PP;
  GPIO_Inilize(GPIO_P5, &GPIO_InitStructure);

  P12 = P13 = P14 = P15 = 0;
}